<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mood Tracker</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React/ReactDOM + Babel para transpilar JSX en el navegador (simple y gratis) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      body { background:#0f172a; color:#e2e8f0; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      // === PASTE DESDE AQUÍ: tu componente del canvas, tal cual ===
      // Usa exactamente el contenido de “Mood Tracker Anual Responsive (mobile-first) – Ericito”
      // O sea: import quítalo; deja solo el componente y helpers.
      // Cambia "export default function MoodTrackerGrid(){...}" por "function MoodTrackerGrid(){...}"
      // y al final: ReactDOM.createRoot(...).render(<MoodTrackerGrid/>)

      // --- INICIO COMPONENTE (simplificado para inline) ---
      const { useEffect, useMemo, useRef, useState, memo } = React;

      const MONTHS_ES=["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"];
      const FULL_MONTHS_ES=["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
      const PALETTE=["#22c55e","#3b82f6","#06b6d4","#6366f1","#ef4444","#f59e0b","#fb7185","#a855f7","#10b981","#eab308","#111827","#ffffff"];

      function pad2(n){ return String(n).padStart(2,"0"); }
      function daysInMonth(y,m){ return new Date(y, m+1, 0).getDate(); }
      function keyFor(y,m,d){ return `${y}-${pad2(m+1)}-${pad2(d)}`; }

      const DB_NAME="mood-tracker"; const DB_VERSION=1;
      const STORE_IMAGES="images"; const STORE_THUMBS="thumbs";
      function openDB(){ return new Promise((resolve,reject)=>{ const req=indexedDB.open(DB_NAME,DB_VERSION);
        req.onupgradeneeded=()=>{const db=req.result; if(!db.objectStoreNames.contains(STORE_IMAGES)) db.createObjectStore(STORE_IMAGES); if(!db.objectStoreNames.contains(STORE_THUMBS)) db.createObjectStore(STORE_THUMBS);};
        req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error); });}
      async function idbGet(store,key){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const st=tx.objectStore(store); const r=st.get(key); r.onsuccess=()=>res(r.result||null); r.onerror=()=>rej(r.error);});}
      async function idbSet(store,key,val){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const st=tx.objectStore(store); const r=st.put(val,key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);});}
      async function idbDel(store,key){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const st=tx.objectStore(store); const r=st.delete(key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);});}

      function MoodTrackerGrid(){
        const now=new Date();
        const [year,setYear]=useState(now.getFullYear());
        const [thumbs,setThumbs]=useState({});
        const [open,setOpen]=useState(false);
        const [target,setTarget]=useState({ y:now.getFullYear(), m:now.getMonth(), d:now.getDate() });

        const monthDays=useMemo(()=>Array.from({length:12},(_,m)=>daysInMonth(year,m)),[year]);

        useEffect(()=>{ let cancelled=false;(async()=>{ const entries={}; const jobs=[];
          for(let m=0;m<12;m++){ for(let d=1; d<=monthDays[m]; d++){ const k=keyFor(year,m,d); jobs.push(idbGet(STORE_THUMBS,k).then(v=>{if(!cancelled&&v) entries[k]=v;}));}}
          await Promise.all(jobs); if(!cancelled) setThumbs(entries);
        })(); return ()=>{cancelled=true}; },[year,monthDays]);

        const openCell=(m,d)=>{ setTarget({y:year,m,d}); setOpen(true); };
        const handleSaved=(k,thumb)=>{ setThumbs(prev=>({...prev,[k]:thumb})); setOpen(false); };
        const clearCell=async(m,d)=>{ const k=keyFor(year,m,d); await Promise.all([idbDel(STORE_IMAGES,k),idbDel(STORE_THUMBS,k)]);
          setThumbs(prev=>{const p={...prev}; delete p[k]; return p;}); };

        const exportJson=async()=>{ const result={year,images:{}}; const jobs=[];
          for(let m=0;m<12;m++){ for(let d=1; d<=monthDays[m]; d++){ const k=keyFor(year,m,d); jobs.push(idbGet(STORE_IMAGES,k).then(v=>{ if(v) result.images[k]=v; }));}}
          await Promise.all(jobs); const payload=JSON.stringify(result,null,2);
          try{ await navigator.clipboard.writeText(payload); alert("Exportado al portapapeles ✅"); }
          catch{ const blob=new Blob([payload],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`mood-grid-${year}.json`; a.click(); URL.revokeObjectURL(url); }
        };
        const importJson=(e)=>{ const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload=async()=>{ try{ const obj=JSON.parse(r.result);
              const yr=obj.year??year; for(const [k,data] of Object.entries(obj.images||{})){ await idbSet(STORE_IMAGES,k,data); const thumb=await makeThumbFromDataURL(data,64); await idbSet(STORE_THUMBS,k,thumb); }
              setYear(yr);
            }catch{ alert("JSON inválido"); } }; r.readAsText(f); };

        return (
          <div className="min-h-screen bg-slate-900 text-slate-100">
            <div className="sticky top-0 z-10 backdrop-blur bg-slate-900/80 border-b border-slate-800">
              <div className="max-w-5xl mx-auto flex items-center gap-2 p-3">
                <button className="px-3 py-2 rounded-xl bg-slate-800 active:scale-95" onClick={()=>setYear(y=>y-1)} aria-label="Año anterior">«</button>
                <div className="flex-1 text-center text-lg font-bold">Mood Tracker {year}</div>
                <button className="px-3 py-2 rounded-xl bg-slate-800 active:scale-95" onClick={()=>setYear(y=>y+1)} aria-label="Año siguiente">»</button>
              </div>
              <div className="max-w-5xl mx-auto flex items-center justify-between gap-2 px-3 pb-3 text-xs">
                <button onClick={exportJson} className="px-3 py-2 rounded-lg bg-slate-800">Exportar</button>
                <label className="px-3 py-2 rounded-lg bg-slate-800 cursor-pointer">Importar
                  <input type="file" accept="application/json" className="hidden" onChange={importJson}/>
                </label>
                <button onClick={()=>{ if(confirm('¿Borrar todas las imágenes del año?')) wipeYear(year, monthDays, setThumbs); }} className="px-3 py-2 rounded-lg bg-red-700/70">Reset</button>
              </div>
            </div>

            <div className="max-w-5xl mx-auto p-3">
              <div className="grid" style={{gridTemplateColumns:`56px repeat(12, minmax(0,1fr))`}}>
                <div></div>
                {MONTHS_ES.map((m,i)=>(<div key={i} className="text-center text-[11px] text-slate-300 py-1">{m}</div>))}
              </div>

              <div className="grid" style={{gridTemplateColumns:`56px repeat(12, minmax(0,1fr))`}}>
                {Array.from({length:31}).map((_,row)=>(
                  <React.Fragment key={row}>
                    <div className="h-10 flex items-center justify-end pr-2 text-[11px] text-slate-400 border-b border-slate-800">{row+1}</div>
                    {Array.from({length:12}).map((_,col)=>{
                      const valid=row<daysInMonth(year,col); const k=keyFor(year,col,row+1); const thumb=thumbs[k];
                      return (
                        <div key={`${col}-${row}`}
                          className={`relative h-10 border-b border-slate-800 border-l border-slate-800 ${valid?'cursor-pointer':'opacity-30'}`}
                          onClick={() => {
                            if (!valid) return;
                            setTarget({ y: year, m: col, d: row + 1 });
                            setOpen(true);
                          }}
                          onContextMenu={(e)=>{ e.preventDefault(); valid && clearCell(col,row+1); }}
                          title={valid? `${FULL_MONTHS_ES[col]} ${row+1}` : ''}
                          style={thumb?{backgroundImage:`url(${thumb})`,backgroundSize:'cover',backgroundPosition:'center'}:undefined}
                        />
                      );
                    })}
                  </React.Fragment>
                ))}
              </div>

              <div className="text-[11px] text-slate-500 mt-3">Tip: Tap para editar. Mantén presionado y suelta (o click derecho) para limpiar un día.</div>
            </div>

            {open && (
              <EditorModal
                key={`${target.y}-${target.m}-${target.d}`}
                title={`${FULL_MONTHS_ES[target.m]} ${target.d}, ${target.y}`}
                dayKey={keyFor(target.y,target.m,target.d)}
                onClose={()=>setOpen(false)}
                onSaved={(k,thumb)=>{ setThumbs(prev=>({...prev,[k]:thumb})); setOpen(false); }}
              />
            )}
            <div className="h-8"/>
          </div>
        );
      }

      function EditorModal({ title, dayKey, onClose, onSaved }){
        const canvasRef=useRef(null);
        const toolRef=useRef({ color:PALETTE[0], size:10, erase:false });
        const [color,setColor]=useState(PALETTE[0]);
        const [size,setSize]=useState(10);
        const [erase,setErase]=useState(false);
        useEffect(()=>{ toolRef.current={color,size,erase}; },[color,size,erase]);
        useEffect(()=>{ (async()=>{
          const canvas=canvasRef.current; if(!canvas) return;
          const DPR=window.devicePixelRatio||1; const W=300,H=300;
          canvas.width=Math.round(W*DPR); canvas.height=Math.round(H*DPR);
          canvas.style.width=W+"px"; canvas.style.height=H+"px";
          const ctx=canvas.getContext('2d'); ctx.setTransform(DPR,0,0,DPR,0,0);
          ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
          const existing=await idbGet("images", dayKey); if(existing){ await drawDataURL(ctx, existing, W, H); }
        })(); },[dayKey]);
        useEffect(()=>{ const canvas=canvasRef.current; if(!canvas) return; const ctx=canvas.getContext('2d'); let drawing=false; let last=null;
          const start=(x,y)=>{drawing=true; last={x,y};}; const move=(x,y)=>{ if(!drawing) return; const {color,size,erase}=toolRef.current;
            ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=size; ctx.globalCompositeOperation=erase?'destination-out':'source-over'; if(!erase) ctx.strokeStyle=color;
            ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke(); last={x,y}; };
          const end=()=>{drawing=false; last=null;};
          const getXY=(e)=>{ const rect=canvas.getBoundingClientRect(); const cx=(e.touches?e.touches[0].clientX:e.clientX), cy=(e.touches?e.touches[0].clientY:e.clientY); return {x:cx-rect.left, y:cy-rect.top};};
          const onDown=e=>{e.preventDefault(); const {x,y}=getXY(e); start(x,y);}; const onMove=e=>{if(!drawing)return; e.preventDefault(); const {x,y}=getXY(e); move(x,y);}; const onUp=e=>{e.preventDefault(); end();};
          canvas.addEventListener('mousedown',onDown); canvas.addEventListener('mousemove',onMove); window.addEventListener('mouseup',onUp);
          canvas.addEventListener('touchstart',onDown,{passive:false}); canvas.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('touchend',onUp);
          return ()=>{ canvas.removeEventListener('mousedown',onDown); canvas.removeEventListener('mousemove',onMove); window.removeEventListener('mouseup',onUp);
            canvas.removeEventListener('touchstart',onDown); canvas.removeEventListener('touchmove',onMove); window.removeEventListener('touchend',onUp); };
        },[]);
        const handleSave=async()=>{ const canvas=canvasRef.current; const full=canvas.toDataURL('image/webp',0.85); const thumb=await makeThumbFromCanvas(canvas,64);
          await idbSet("images",dayKey,full); await idbSet("thumbs",dayKey,thumb); onSaved(dayKey,thumb); };
        const handleClear=async()=>{ const canvas=canvasRef.current; const ctx=canvas.getContext('2d'); const DPR=window.devicePixelRatio||1; const W=canvas.width/DPR, H=canvas.height/DPR; ctx.setTransform(DPR,0,0,DPR,0,0); ctx.fillStyle='#0f172a'; ctx.globalCompositeOperation='source-over'; ctx.fillRect(0,0,W,H); };
        return (
          <div className="fixed inset-0 z-20">
            <div className="absolute inset-0 bg-black/60" onClick={onClose}/>
            <div className="absolute bottom-0 left-0 right-0 bg-slate-900 rounded-t-2xl border-t border-slate-700 p-4 max-w-md mx-auto">
              <div className="h-1 w-10 bg-slate-600 rounded-full mx-auto mb-3"/>
              <div className="text-center font-semibold mb-2">{title}</div>
              <div className="flex items-center justify-center"><canvas ref={canvasRef} className="rounded-xl ring-1 ring-slate-700 touch-none"/></div>
              <div className="mt-3 grid grid-cols-8 gap-2">{PALETTE.map(c=>(<button key={c} onClick={()=>{setColor(c); setErase(false);}} className={`h-8 rounded-lg ring-1 ring-slate-700 ${color===c&&!erase?'scale-95':''}`} style={{backgroundColor:c}}/>))}</div>
              <div className="mt-3 flex items-center gap-3">
                <label className="text-xs text-slate-300">Grosor</label>
                <input type="range" min={2} max={40} value={size} onChange={e=>setSize(Number(e.target.value))} className="flex-1"/>
                <div className="w-6 h-6 rounded-full" style={{backgroundColor: erase? '#0f172a' : color, border: '1px solid rgba(255,255,255,0.2)'}}></div>
                <button onClick={()=>setErase(e=>!e)} className={`px-3 py-2 rounded-lg ${erase?'bg-rose-600':'bg-slate-800'}`}>{erase?'Borrar':'Dibujar'}</button>
              </div>
              <div className="mt-3 flex gap-2">
                <button onClick={handleSave} className="flex-1 py-2 rounded-xl bg-emerald-600 font-semibold active:scale-95">Guardar</button>
                <button onClick={handleClear} className="px-4 py-2 rounded-xl bg-slate-800 active:scale-95">Limpiar</button>
                <button onClick={onClose} className="px-4 py-2 rounded-xl bg-slate-800 active:scale-95">Cerrar</button>
              </div>
              <div className="text-[11px] text-slate-500 mt-2">Tip: dibuja con el dedo; usa el botón Borrar para corregir.</div>
            </div>
          </div>
        );
      }

      async function wipeYear(year, monthDays, setThumbs){
        if(!confirm(`Confirmar borrar imágenes de ${year}?`)) return;
        const jobs=[]; for(let m=0;m<12;m++){ for(let d=1; d<=monthDays[m]; d++){ const k=keyFor(year,m,d); jobs.push(idbDel("images",k)); jobs.push(idbDel("thumbs",k));}}
        await Promise.all(jobs); setThumbs({});
      }
      async function drawDataURL(ctx, dataURL, W, H){ return new Promise((res)=>{ const img=new Image(); img.onload=()=>{ ctx.drawImage(img,0,0,W,H); res(); }; img.src=dataURL; }); }
      async function makeThumbFromCanvas(canvas, size=64){ const DPR=window.devicePixelRatio||1; const W=canvas.width/DPR, H=canvas.height/DPR; const s=document.createElement('canvas'); s.width=size; s.height=size; const c=s.getContext('2d'); c.fillStyle='#0f172a'; c.fillRect(0,0,size,size); c.drawImage(canvas,0,0,W,H,0,0,size,size); return s.toDataURL('image/webp',0.8); }
      async function makeThumbFromDataURL(dataURL, size=64){ const img=new Image(); await new Promise(res=>{ img.onload=res; img.src=dataURL; }); const s=document.createElement('canvas'); s.width=size; s.height=size; const c=s.getContext('2d'); c.fillStyle='#0f172a'; c.fillRect(0,0,size,size); c.drawImage(img,0,0,img.width,img.height,0,0,size,size); return s.toDataURL('image/webp',0.8); }

      ReactDOM.createRoot(document.getElementById('root')).render(<MoodTrackerGrid/>);
      // --- FIN COMPONENTE ---
    </script>
  </body>
</html>




