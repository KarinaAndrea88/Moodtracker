<!doctype html>
<html lang="es">
  <head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Mood Tracker – Ericito</title>
    <!-- Tailwind CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React/ReactDOM + Babel para transpilar JSX en el navegador -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
      :root { color-scheme: dark; }
      body { background:#0f172a; color:#e2e8f0; }
      /* barra de scroll de la paleta */
      .scrollbar-thin::-webkit-scrollbar { height: 6px; }
      .scrollbar-thin::-webkit-scrollbar-thumb { background: #334155; border-radius: 9999px; }
    </style>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useEffect, useMemo, useRef, useState, memo } = React;

      // --- Constantes/UI ---
      const MONTHS_ES=["Ene","Feb","Mar","Abr","May","Jun","Jul","Ago","Sep","Oct","Nov","Dic"];
      const FULL_MONTHS_ES=["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
      const PALETTE=["#22c55e","#3b82f6","#06b6d4","#6366f1","#ef4444","#f59e0b","#fb7185","#a855f7","#10b981","#eab308","#111827","#ffffff"];

      function pad2(n){ return String(n).padStart(2,"0"); }
      function daysInMonth(y,m){ return new Date(y, m+1, 0).getDate(); }
      function keyFor(y,m,d){ return `${y}-${pad2(m+1)}-${pad2(d)}`; }

      // --- IndexedDB helpers ---
      const DB_NAME="mood-tracker"; const DB_VERSION=1;
      const STORE_IMAGES="images"; const STORE_THUMBS="thumbs";
      function openDB(){ return new Promise((resolve,reject)=>{ const req=indexedDB.open(DB_NAME,DB_VERSION);
        req.onupgradeneeded=()=>{const db=req.result; if(!db.objectStoreNames.contains(STORE_IMAGES)) db.createObjectStore(STORE_IMAGES); if(!db.objectStoreNames.contains(STORE_THUMBS)) db.createObjectStore(STORE_THUMBS);};
        req.onsuccess=()=>resolve(req.result); req.onerror=()=>reject(req.error); });}
      async function idbGet(store,key){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readonly'); const st=tx.objectStore(store); const r=st.get(key); r.onsuccess=()=>res(r.result||null); r.onerror=()=>rej(r.error);});}
      async function idbSet(store,key,val){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const st=tx.objectStore(store); const r=st.put(val,key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);});}
      async function idbDel(store,key){ const db=await openDB(); return new Promise((res,rej)=>{ const tx=db.transaction(store,'readwrite'); const st=tx.objectStore(store); const r=st.delete(key); r.onsuccess=()=>res(); r.onerror=()=>rej(r.error);});}

      // --- Utils thumbs (contain + centrado, cuadrado) ---
      async function makeThumbFromCanvas(canvas, size = 96) {
        const s = document.createElement('canvas'); s.width = size; s.height = size;
        const c = s.getContext('2d');
        c.fillStyle = '#0f172a'; c.fillRect(0, 0, size, size);
        // Scale the entire canvas to fit the thumbnail exactly
        c.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, size, size);
        return s.toDataURL('image/webp', 0.85);
      }
      async function makeThumbFromDataURL(dataURL, size=96){
        const img=new Image(); await new Promise(res=>{ img.onload=res; img.src=dataURL; });
        const s=document.createElement('canvas'); s.width=size; s.height=size; const c=s.getContext('2d');
        c.fillStyle='#0f172a'; c.fillRect(0,0,size,size);
        // Scale the entire image to fit the thumbnail exactly
        c.drawImage(img, 0,0,img.width,img.height, 0,0,size,size);
        return s.toDataURL('image/webp', 0.85);
      }

      // --- Componente principal ---
      function MoodTrackerGrid(){
        const now=new Date();
        const [year,setYear]=useState(now.getFullYear());
        const [thumbs,setThumbs]=useState({});
        const [open,setOpen]=useState(false);
        const [target,setTarget]=useState({ y:now.getFullYear(), m:now.getMonth(), d:now.getDate() });

        // tamaño fijo cuadrado por celda (px)
        const [cell,setCell]=useState(32);

        const monthDays=useMemo(()=>Array.from({length:12},(_,m)=>daysInMonth(year,m)),[year]);

        // carga thumbs del año
        useEffect(()=>{ let cancelled=false;(async()=>{ const entries={}; const jobs=[];
          for(let m=0;m<12;m++){ for(let d=1; d<=monthDays[m]; d++){ const k=keyFor(year,m,d); jobs.push(idbGet(STORE_THUMBS,k).then(v=>{ if(!cancelled && v) entries[k]=v; }));}}
          await Promise.all(jobs); if(!cancelled) setThumbs(entries);
        })(); return ()=>{cancelled=true}; },[year,monthDays]);

        const openCell=(m,d)=>{ setTarget({y:year,m,d}); setOpen(true); };
        const handleSaved=(k,thumb)=>{ setThumbs(prev=>({...prev,[k]:thumb})); setOpen(false); };
        const clearCell=async(m,d)=>{ const k=keyFor(year,m,d); await Promise.all([idbDel(STORE_IMAGES,k), idbDel(STORE_THUMBS,k)]); setThumbs(p=>{const c={...p}; delete c[k]; return c;}); };

        const exportJson=async()=>{ const result={year,images:{}}; const jobs=[];
          for(let m=0;m<12;m++){ for(let d=1; d<=monthDays[m]; d++){ const k=keyFor(year,m,d); jobs.push(idbGet(STORE_IMAGES,k).then(v=>{ if(v) result.images[k]=v; }));}}
          await Promise.all(jobs); const payload=JSON.stringify(result,null,2);
          try{ await navigator.clipboard.writeText(payload); alert("Exportado al portapapeles ✅"); }
          catch{ const blob=new Blob([payload],{type:"application/json"}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`mood-grid-${year}.json`; a.click(); URL.revokeObjectURL(url); }
        };
        const importJson=(e)=>{ const f=e.target.files?.[0]; if(!f) return; const r=new FileReader(); r.onload=async()=>{ try{ const obj=JSON.parse(r.result);
              const yr=obj.year??year; for(const [k,data] of Object.entries(obj.images||{})){ await idbSet(STORE_IMAGES,k,data); const thumb=await makeThumbFromDataURL(data,96); await idbSet(STORE_THUMBS,k,thumb); }
              setYear(yr);
            }catch{ alert("JSON inválido"); } }; r.readAsText(f); };

        return (
          <div className="min-h-screen bg-slate-900 text-slate-100">
            {/* Top bar */}
            <div className="sticky top-0 z-10 backdrop-blur bg-slate-900/80 border-b border-slate-800">
              <div className="max-w-5xl mx-auto flex items-center gap-2 p-3">
                <button className="px-3 py-2 rounded-xl bg-slate-800 active:scale-95" onClick={()=>setYear(y=>y-1)} aria-label="Año anterior">«</button>
                <div className="flex-1 text-center text-lg font-bold">Mood Tracker {year}</div>
                <button className="px-3 py-2 rounded-xl bg-slate-800 active:scale-95" onClick={()=>setYear(y=>y+1)} aria-label="Año siguiente">»</button>
              </div>
              <div className="max-w-5xl mx-auto flex items-center justify-between gap-2 px-3 pb-2 text-xs">
                <button onClick={exportJson} className="px-3 py-2 rounded-lg bg-slate-800">Exportar</button>
                <label className="px-3 py-2 rounded-lg bg-slate-800 cursor-pointer">Importar
                  <input type="file" accept="application/json" className="hidden" onChange={importJson}/>
                                </label>
                <div className="flex items-center gap-2">
                  <span className="text-slate-400">Tamaño celda</span>
                  <input type="range" min="24" max="56" value={cell} onChange={e=>setCell(Number(e.target.value))}/>
                </div>
                </div>
            </div>

            {/* Grid anual */}
            <div className="max-w-5xl mx-auto p-3">
              {/* Header de meses */}
              <div className="grid overflow-x-auto" style={{gridTemplateColumns: `56px repeat(12, ${cell}px)`}}>
                <div></div>
                {MONTHS_ES.map((m,i)=>(
                  <div key={i} className="text-center text-[11px] text-slate-300 py-1" style={{width:`${cell}px`}}>{m}</div>
                ))}
              </div>

              {/* Tabla */}
              <div className="grid overflow-x-auto" style={{gridTemplateColumns: `56px repeat(12, ${cell}px)`}}>
                {Array.from({length:31}).map((_,row)=>(
                  <React.Fragment key={row}>
                    <div className="flex items-center justify-end pr-2 text-[11px] text-slate-400 border-b border-slate-800" style={{height:`${cell}px`}}>{row+1}</div>
                    {Array.from({length:12}).map((_,col)=>{
                      const valid=row<monthDays[col];
                      const k=keyFor(year,col,row+1);
                      const thumb=thumbs[k];
                      return (
                        <GridCell
                          key={`${col}-${row}`}
                          title={valid? `${FULL_MONTHS_ES[col]} ${row+1}` : ''}
                          valid={valid}
                          thumb={thumb}
                          cell={cell}
                          onOpen={()=>{ if(!valid) return; setTarget({y:year,m:col,d:row+1}); setOpen(true); }}
                          onClear={(e)=>{ e.preventDefault(); valid && clearCell(col,row+1); }}
                        />
                      );
                    })}
                  </React.Fragment>
                ))}
              </div>

              <div className="text-[11px] text-slate-500 mt-3">Tip: Tap para editar. Mantén presionado y suelta (o click derecho) para limpiar un día.</div>
            </div>

            {/* Modal de dibujo */}
            {open && (
              <EditorModal
                key={`${target.y}-${target.m}-${target.d}`}
                title={`${FULL_MONTHS_ES[target.m]} ${target.d}, ${target.y}`}
                dayKey={keyFor(target.y,target.m,target.d)}
                onClose={()=>setOpen(false)}
                onSaved={handleSaved}
              />
            )}

            <div className="h-8"/>
          </div>
        );
      }

      const GridCell = memo(function GridCell({ valid, thumb, onOpen, onClear, title, cell }){
        return (
          <div
            className={`relative border-b border-slate-800 border-l border-slate-800 ${valid? 'cursor-pointer' : 'opacity-30'}`}
            onClick={onOpen}
            onContextMenu={onClear}
            title={title}
            style={{ width: `${cell}px`, height: `${cell}px`, backgroundColor: '#0f172a' }}
          >
            {thumb && (
              <img src={thumb} alt="" draggable={false}
                   style={{ width: '100%', height: '100%', objectFit: 'contain' }} />
            )}
          </div>
        );
      });

      function EditorModal({ title, dayKey, onClose, onSaved }){
        const canvasRef=useRef(null);
        const toolRef=useRef({ color:PALETTE[0], size:10, erase:false });
        const [color,setColor]=useState(PALETTE[0]);
        const [size,setSize]=useState(10);
        const [erase,setErase]=useState(false);
        useEffect(()=>{ toolRef.current={color,size,erase}; },[color,size,erase]);

        // preparar canvas + cargar imagen existente
        useEffect(()=>{ (async()=>{
          const canvas=canvasRef.current; if(!canvas) return;
          const W=300,H=300;
          canvas.width=W; canvas.height=H;
          canvas.style.width=W+"px"; canvas.style.height=H+"px";
          const ctx=canvas.getContext('2d');
          ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,W,H);
          const existing=await idbGet(STORE_IMAGES, dayKey); if(existing){ await drawDataURL(ctx, existing, W, H); }
        })(); },[dayKey]);

        // listeners (no matar clicks touch)
        useEffect(()=>{ const canvas=canvasRef.current; if(!canvas) return; const ctx=canvas.getContext('2d'); let drawing=false; let last=null;
          const start=(x,y)=>{drawing=true; last={x,y};};
          const move=(x,y)=>{ if(!drawing) return; const {color,size,erase}=toolRef.current;
            ctx.lineCap='round'; ctx.lineJoin='round'; ctx.lineWidth=size; ctx.globalCompositeOperation=erase?'destination-out':'source-over'; if(!erase) ctx.strokeStyle=color;
            ctx.beginPath(); ctx.moveTo(last.x,last.y); ctx.lineTo(x,y); ctx.stroke(); last={x,y}; };
          const end=()=>{drawing=false; last=null;};
          const getXY=(e)=>{ 
            const r=canvas.getBoundingClientRect(); 
            const cx=(e.touches?e.touches[0].clientX:e.clientX), cy=(e.touches?e.touches[0].clientY:e.clientY); 
            // Simple coordinate conversion
            const x = (cx - r.left) * (300 / r.width);
            const y = (cy - r.top) * (300 / r.height);
            return {x, y}; 
          };
          const onDown=e=>{ e.preventDefault(); const {x,y}=getXY(e); start(x,y); };
          const onMove=e=>{ if(!drawing) return; e.preventDefault(); const {x,y}=getXY(e); move(x,y); };
          const onUp=()=>{ end(); };

          canvas.addEventListener('mousedown',onDown); canvas.addEventListener('mousemove',onMove); window.addEventListener('mouseup',onUp);
          canvas.addEventListener('touchstart',onDown,{passive:false}); canvas.addEventListener('touchmove',onMove,{passive:false}); window.addEventListener('touchend',onUp);
          return ()=>{ canvas.removeEventListener('mousedown',onDown); canvas.removeEventListener('mousemove',onMove); window.removeEventListener('mouseup',onUp);
            canvas.removeEventListener('touchstart',onDown); canvas.removeEventListener('touchmove',onMove); window.removeEventListener('touchend',onUp); };
        },[]);

        const handleSave=async()=>{ const canvas=canvasRef.current; const full=canvas.toDataURL('image/webp',0.85); const thumb=await makeThumbFromCanvas(canvas,96);
          await idbSet(STORE_IMAGES,dayKey,full); await idbSet(STORE_THUMBS,dayKey,thumb); onSaved(dayKey,thumb); };
        const handleClear=async()=>{ const canvas=canvasRef.current; const ctx=canvas.getContext('2d'); ctx.fillStyle='#0f172a'; ctx.globalCompositeOperation='source-over'; ctx.fillRect(0,0,300,300); };

        return (
          <div className="fixed inset-0 z-20">
            <div className="absolute inset-0 bg-black/60" onClick={onClose}/>
            <div className="absolute bottom-0 left-0 right-0 bg-slate-900 rounded-t-2xl border-t border-slate-700 p-4 max-w-md mx-auto">
              <div className="h-1 w-10 bg-slate-600 rounded-full mx-auto mb-3"/>
              <div className="text-center font-semibold mb-2">{title}</div>

              <div className="flex items-center justify-center">
                <canvas ref={canvasRef} className="rounded-xl ring-1 ring-slate-700 touch-none"/>
              </div>

              {/* Paleta (touch-friendly) */}
              <div className="mt-3 grid grid-flow-col auto-cols-max gap-2 overflow-x-auto pb-2 scrollbar-thin">
                {PALETTE.map(c=>(
                  <button key={c}
                    onClick={()=>{ setColor(c); setErase(false); }}
                    onTouchStart={()=>{ setColor(c); setErase(false); }}
                    className={`h-8 w-8 rounded-lg ring-1 ring-slate-700 ${color===c && !erase ? 'scale-95' : ''}`}
                    style={{backgroundColor:c}}
                  />
                ))}
              </div>

              <div className="mt-3 flex items-center gap-3">
                <label className="text-xs text-slate-300">Grosor</label>
                <input type="range" min={2} max={40} value={size} onChange={e=>setSize(Number(e.target.value))} className="flex-1"/>
                <div className="w-6 h-6 rounded-full" style={{backgroundColor: erase? '#0f172a' : color, border: '1px solid rgba(255,255,255,0.2)'}}></div>
                <button onClick={()=>setErase(e=>!e)} className={`px-3 py-2 rounded-lg ${erase?'bg-rose-600':'bg-slate-800'}`}>{erase?'Borrar':'Dibujar'}</button>
              </div>

              <div className="mt-3 flex gap-2">
                <button onClick={handleSave} className="flex-1 py-2 rounded-xl bg-emerald-600 font-semibold active:scale-95">Guardar</button>
                <button onClick={handleClear} className="px-4 py-2 rounded-xl bg-slate-800 active:scale-95">Limpiar</button>
                <button onClick={onClose} className="px-4 py-2 rounded-xl bg-slate-800 active:scale-95">Cerrar</button>
              </div>

              <div className="text-[11px] text-slate-500 mt-2">Tip: dibuja con el dedo; elige color tocando los cuadraditos.</div>
            </div>
          </div>
        );
      }

      async function drawDataURL(ctx, dataURL, W, H){
        return new Promise((resolve)=>{ const img=new Image(); img.onload=()=>{ ctx.drawImage(img,0,0,W,H); resolve(); }; img.src=dataURL; });
      }

      ReactDOM.createRoot(document.getElementById('root')).render(<MoodTrackerGrid/>);
    </script>
  </body>
</html>
